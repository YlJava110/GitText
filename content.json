{"meta":{"title":"chenyulong","subtitle":"Use diary to record daily work and life happened。","description":null,"author":"Nunu Long","url":"http://nunu03.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2019-07-02T12:22:39.000Z","comments":true,"path":"categories/index.html","permalink":"http://nunu03.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-02T12:25:40.000Z","updated":"2019-07-02T12:29:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://nunu03.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"腾讯加固脱壳使用事例","slug":"tencentfdex","date":"2019-07-03T12:23:01.000Z","updated":"2019-07-05T03:42:15.000Z","comments":true,"path":"2019/07/03/tencentfdex/","link":"","permalink":"http://nunu03.github.io/2019/07/03/tencentfdex/","excerpt":"概述本文只介绍具体的原理和实现，不涉及Xposed相关技术点。想要了解Xposed具体配置和实现的请参考Xposed的配置与简单使用 原理通过Hook ClassLoader的loadClass方法，反射调用getDex方法取得Dex(com.android.dex.Dex类对象)，在将里面的dex写出。","text":"概述本文只介绍具体的原理和实现，不涉及Xposed相关技术点。想要了解Xposed具体配置和实现的请参考Xposed的配置与简单使用 原理通过Hook ClassLoader的loadClass方法，反射调用getDex方法取得Dex(com.android.dex.Dex类对象)，在将里面的dex写出。 直接反编译apk 脱壳获取dex的关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private static void fDex(XC_LoadPackage.LoadPackageParam loadPackageParam2)&#123; if(loadPackageParam2.packageName.equals(&quot;com.luhu.livexiuwu&quot;))&#123; try &#123; Class Dex=Class.forName(&quot;com.android.dex.Dex&quot;); Method Dex_getBytes=Dex.getDeclaredMethod(&quot;getBytes&quot;, new Class[0]); Method getDex = Class.forName(&quot;java.lang.Class&quot;).getDeclaredMethod(&quot;getDex&quot;, new Class[0]); XposedBridge.log(&quot;-------------------5&quot;); XposedHelpers.findAndHookMethod(&quot;java.lang.ClassLoader&quot;, loadPackageParam2.classLoader, &quot;loadClass&quot;, String.class,boolean.class,new XC_MethodHook()&#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; XposedBridge.log(&quot;-------------------7&quot;); Class cls = (Class) param.getResult(); XposedBridge.log(&quot;-------------------8&quot;+cls); if (cls != null) &#123; try &#123; byte[] bArr = (byte[]) Dex_getBytes.invoke(getDex.invoke(cls, new Object[0]), new Object[0]); XposedBridge.log(&quot;-------------------9&quot;+bArr); if (bArr != null) &#123; File apkFileDir = new File(CompatUtil.getSdcardSharedDir(), &quot;lulu&quot;); if (!apkFileDir.exists()) &#123; apkFileDir.mkdirs(); &#125; String name = &quot;com.luhu.livexiuwu&quot;+bArr.length+&quot;.dex&quot;; File file2 = new File(apkFileDir, name); XposedBridge.log(&quot;-------------------&quot;+file2.getAbsolutePath()); if (!file2.exists()) &#123; FileUtil.writeToFileBy(bArr, file2); &#125; &#125; &#125; catch (Exception e3) &#123; XposedBridge.log(&quot;-------------------&quot;+e3.toString()); &#125; &#125; &#125; &#125;); &#125; catch (Throwable e) &#123; XposedBridge.log(e); &#125; &#125; &#125; 脱壳工具FDex2 脱壳流程第一步、激活FDex2和需要脱壳的应用都安装到手机上。在Xposed install模块中勾选FDex2，重启手机。 第二步、选择软件然后打开FDex2应用，在应用列表中选择需要脱壳的应用，保存dex即可。 第三步、运行软件运行要脱壳的软件，不打开运行软件是无法脱出壳的 第四步、dex目录找到dex目录，这里的dex就是脱壳后的dex文件，也就是我即将hook的dex文件。目录一般是/data/user/0/com.luhu.package.xxx。 hook过程由于被腾讯加固，所以第一步是需要获取对应ClassLoader；在之后的逆向过程中使用的ClassLoader都是这个ClassLoader。 123456789101112131415161718192021if(lpparam.packageName.startsWith(&quot;com.luhu.livexiuwu&quot;))&#123; try &#123; //腾讯加固，需要获取对应classloader XposedHelpers.findAndHookMethod(&quot;com.tencent.StubShell.TxAppEntry&quot;, lpparam.classLoader, &quot;attachBaseContext&quot;, Context.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); //获取到Context对象，通过这个对象来获取classloader Context context = (Context) param.args[0]; //获取classloader，之后hook加固后的就使用这个classloader SecApp.hookLuhu(lpparam,context.getClassLoader()); &#125; &#125;); &#125;catch (Exception e)&#123; &#125; &#125; 参考资料java and android 架构","categories":[{"name":"Android","slug":"Android","permalink":"http://nunu03.github.io/categories/Android/"}],"tags":[{"name":"Xposed","slug":"Xposed","permalink":"http://nunu03.github.io/tags/Xposed/"}]},{"title":"Xposed的配置与简单使用","slug":"xposed","date":"2019-07-02T05:20:51.000Z","updated":"2019-07-04T12:00:00.000Z","comments":true,"path":"2019/07/02/xposed/","link":"","permalink":"http://nunu03.github.io/2019/07/02/xposed/","excerpt":"Xposed是什么官方对此的解释是这样的：“Xposed是一个适用于Android的框架。基于这个框架开发的模块可以改变系统和app应用的行为，而不需要修改APK。这是一个很棒的特性，意味着Xposed模块可以不经过任何修改，安装在各种不同的ROM上。Xposed模块可以很容易的开启和关闭。你只需要激活或者禁用Xposed模块，然后重启手机即可。”","text":"Xposed是什么官方对此的解释是这样的：“Xposed是一个适用于Android的框架。基于这个框架开发的模块可以改变系统和app应用的行为，而不需要修改APK。这是一个很棒的特性，意味着Xposed模块可以不经过任何修改，安装在各种不同的ROM上。Xposed模块可以很容易的开启和关闭。你只需要激活或者禁用Xposed模块，然后重启手机即可。” Hook是什么Hook 英文就是「挂钩」的意思.那我们如何使用这个「挂钩」呢？在我们的应用程序种，包括应用触发事件和后台逻辑处理，都是是根据事件流程一步步地向下执行。而「挂钩」的意思，就是在事件传送到终点前截获并监控事件的传输，像个钩子钩上事件一样，并且能够在钩上事件时，处理一些自己特定的事件。如何理解，例如我们有一个方法： 123private int getResult(int i, int i2) &#123; return i+i2; &#125; 正常情况下，i=1，i2=1，我们能得到2，但是根据上图，现在我们知道利用Hook现在能做些什么了，通过Hook我们可以对参数i，i2进行修改，i=1，i2=2，最终我们得到的结果是3.这就是挂钩的作用。 关于Android中的Hook机制，大致有两个方式： 要 root 权限，直接Hook系统，可以干掉所有的App。 免root权限，但是只能 Hook 自身，对系统其它 App 无能为力。 Xposed接入创建工程这个工程就是我们的插件工程，也是我们需要激活的Xposed模块工程。在我们的群控项目中，我们的hotB就是我们的模块工程。什么是模块工程，可以理解我们使用Hook挂钩自定义消息体的工程。这个app安装后可以在Xposed app的模块中找到。 导入api倒入api比较简单：直接在build.gradle中添加依赖即可： 123/* Xposed */ provided &apos;de.robv.android.xposed:api:82&apos; provided &apos;de.robv.android.xposed:api:82:sources&apos; 注意：这里是provided，因为Xposed里已有该jar包内容，再次打包进去会冲突，并导致handleLoadPackage没有回调 修改AndroidManifest.xml文件在标签里面加三个meta-data 123456&lt;!-- 作为xposed模块 --&gt;&lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;!-- Xposed的模块描述 显示在xposed模块列表那里第二行--&gt;&lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;HotAX&quot; /&gt;&lt;!-- XposedBridgeApi的最低版本号 --&gt;&lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;53&quot; /&gt; 编写hook类创建一个类，实现IXposedHookLoadPackage接口，重写handleLoadPackage方法： 123456789101112131415161718192021public class XposedModule implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; if (!loadPackageParam.packageName.startsWith(&quot;com.hotax.autowechat&quot;)) &#123; if (loadPackageParam.packageName.startsWith(&quot;com.tencent.mm&quot;)) &#123; XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; &#125; &#125;); &#125; &#125; &#125;&#125; 创建xposed_init文件在main/assets目录下创建xposed_init文件，不要后缀名。这个就是模块的入口，只有一行代码，就是说明入口类,这个类就是我们上边的类，在这里我们能打印出所有package。 1com.hotax.autowechat.xposed.XposedModule。 至此，Xposed模块开发的接入就全部完成了。 Hook实现hook变量hook前 123456789private static int staticPrivateInt = 100;public static int staticPublicInt = 100;private static String staticPrivateString = &quot;staticPrivateString&quot;;private static String staticPublicString = &quot;staticPublicString&quot;;public int publicInt = 200;private int privateInt = 300;private String privateString = &quot;privateString&quot;;private String publicString = &quot;publicString&quot;; hook 获取Class： final Class&lt;?&gt; clazz = XposedHelpers.findClass(“全路径类名”, loadPackageParam.classLoader); 123456XposedHelpers.setStaticIntField(clazz, &quot;staticPrivateInt&quot;, 99);XposedHelpers.setStaticIntField(clazz, &quot;staticPublicInt&quot;, 99);XposedHelpers.setStaticObjectField(clazz, &quot;staticPrivateString&quot;, &quot;hook_staticPrivateString&quot;);XposedHelpers.setStaticObjectField(clazz, &quot;staticPublicString&quot;, &quot;hook_staticPublicString&quot;);XposedHelpers.setStaticIntField(clazz, &quot;publicInt&quot;, 99); hook后结果打印 12345678D/HookDemo: staticPrivateInt = 99D/HookDemo: staticPublicInt = 99D/HookDemo: staticPrivateString = hook_staticPrivateStringD/HookDemo: staticPublicString = hook_staticPublicStringD/HookDemo: publicInt = 200D/HookDemo: privateInt = 300D/HookDemo: privateString = privateStringD/HookDemo: publicString = publicString 结论：XposedHelpers.setStaticObjectField方法只能修改静态变量，非静态变量不能使用此方式修改。否则会报java.lang.NullPointerException:异常；那非静态变量如何修改呢：例如我们目标程序里有两个方法 1234567public void publicMethod(String value)&#123; Log.d(Tag, &quot;参数打印-publicMethod：&quot; + value);&#125;private void privateMethod(String value)&#123; Log.d(Tag, &quot;参数打印-privateMethod：&quot; + value);&#125; hook非静态变量 1234567891011121314151617XposedHelpers.findAndHookMethod(clazz, &quot;publicFunc&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;before--------------publicMethod&quot;; XposedHelpers.setIntField(param.thisObject, &quot;publicInt&quot;, 199); XposedHelpers.setIntField(param.thisObject, &quot;privateInt&quot;, 199); XposedHelpers.setObjectField(param.thisObject, &quot;privateString&quot;, &quot;hook_privateString&quot;); XposedHelpers.setObjectField(param.thisObject, &quot;publicString&quot;, &quot;hook_publicString&quot;); XposedHelpers.setIntField(param.thisObject, &quot;staticPrivateInt&quot;, 199); XposedHelpers.setIntField(param.thisObject, &quot;staticPublicInt&quot;, 199); XposedHelpers.setObjectField(param.thisObject, &quot;staticPrivateString&quot;, &quot;hook_-setObjectField-staticPrivateString&quot;); XposedHelpers.setObjectField(param.thisObject, &quot;staticPublicString&quot;, &quot;hook_-setObjectField-staticPublicString&quot;); &#125;&#125;); hook后结果打印 123456789参数打印-publicMethod：before--------------publicMethodD/HookDemo: staticPrivateInt = 199D/HookDemo: staticPublicInt = 199D/HookDemo: staticPrivateString = hook_-setObjectField-staticPrivateStringD/HookDemo: staticPublicString = hook_-setObjectField-staticPublicStringD/HookDemo: publicInt = 199D/HookDemo: privateInt = 199D/HookDemo: privateString = hook_privateStringD/HookDemo: publicString = hook_publicString 结论：非静态变量的修改只能通过反射某类中的某个方法（方法类型不限）中修改，且静态变量也可以这么修改。 hook方法hook构造方法12345678910111213141516171819202122public HookDemo(String value)&#123; Log.d(Tag, &quot;参数打印-带参构造方法：&quot; + value);&#125;-------------------------------------------------------------------//Hook有参构造函数，修改参数 XposedHelpers.findAndHookConstructor(clazz, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;参数打印-带参构造方法：我是修改后的参数&quot;; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; XposedBridge.log(&quot;HOOK-After：&quot; +param.args[0]); &#125; &#125;); -------------------------------------------------------------------D/HookDemo: 参数打印-带参构造方法：我是修改后的参数D/HookDemo: HOOK-After：参数打印-带参构造方法：我是修改后的参数 hook带返回值的方法123456789101112131415161718192021222324252627282930313233public String getHook(String value)&#123; return value;&#125; -------------------------------------------------------------------1、XposedHelpers.findAndHookMethod(clazz, &quot;getHook&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;返回值：before--------------gethook&quot;; &#125;&#125;); 执行结果：D/HookDemo: getHook 返回值 = 返回值：before--------------gethook-------------------------------------------------------------------2、 XposedHelpers.findAndHookMethod(clazz, &quot;getHook&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;// param.args[0] = &quot;返回值：before--------------gethook&quot;; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; param.setResult(&quot;返回值：after--------------gethook&quot;); &#125; &#125;); 执行结果：D/HookDemo: getHook 返回值 = 返回值：after--------------gethook hook静态方法1234567891011121314151617181920212223242526272829303132333435363738394041424344private static String staticPrivateMethod(String value)&#123; Log.d(&quot;HookDemo&quot;, &quot;静态函数--&quot; + value); return &quot;静态函数--返回：&quot;+value;&#125;-------------------------------------------------------------------1、XposedHelpers.findAndHookMethod(clazz, &quot;staticPrivateMethod&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;before---&quot;; &#125; &#125;); 执行结果：D/HookDemo: 静态函数--before---D/HookDemo: 静态函数--返回：before----------------------------------------------------------------------2、XposedHelpers.findAndHookMethod(clazz, &quot;staticPrivateMethod&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;before---&quot;; &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; param.setResult(&quot;静态函数--返回：after---&quot;); &#125; &#125;);执行结果：D/HookDemo: 静态函数--before---D/HookDemo: 静态函数--返回：after----------------------------------------------------------------------3、Object object = XposedHelpers.callStaticMethod(clazz, &quot;staticPrivateMethod&quot;, &quot;callStaticMethod 静态函数调用&quot;);Log.d(&quot;HookDemo&quot;, &quot;xposed-:staticPrivateFunc:&quot;+object);执行结果：D/HookDemo: 静态函数--callStaticMethod 静态函数调用D/HookDemo: xposed-:staticPrivateFunc:静态函数--返回：callStaticMethod 静态函数调用 结论：静态方法的修改和其他方法hook方式一样，但是静态方法可以直接通过callStaticMethod进行参数的修改。 Hook复杂的参数123456789101112public void paramsClass(ClasName cn, String value,Intent intent,int key,Map map,List list)&#123; &#125;-------------------------------------------------------------------Class cnClazz = loadPackageParam.classLoader.loadClass(&quot;com.xxxx. ClasName&quot;);Class cnMap = XposedHelpers.findClass(&quot;java.util.Map&quot;, loadPackageParam.classLoader);Class cnArrayList = XposedHelpers.findClass(&quot;java.util.ArrayList&quot;, loadPackageParam.classLoader);XposedHelpers.findAndHookMethod(clazz, &quot;paramsClass&quot;, cnClazz, String.class, Intent.class,int.class,Map.class,ArrayList.class new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; &#125;&#125;); Hook内部类中的函数123456789101112131415161718public class HookDemo &#123; private String Tag = &quot;HookDemo&quot;; class InnerClass&#123; public int innerPublicInt = 10; private int innerPrivateInt = 20; public InnerClass()&#123; &#125; public void InnerFunc(String value)&#123; &#125; &#125;&#125;-------------------------------------------------------------------final Class&lt;?&gt; clazz1 = XposedHelpers.findClass(&quot;com.xxxxxx.HookDemo$InnerClass&quot;, loadPackageParam.classLoader);XposedHelpers.findAndHookMethod(clazz1, &quot;InnerMethod&quot;, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; &#125; &#125;); 注：hook内部类中的函数和变量，跟以上的hook方式没有区别，唯一的区别是，XposedHelpers.findClass中的路径名不同。 Hook匿名内部类中的函数12345678910111213141516anonymousInner(new ClasName() &#123; @Override public void clasNameMethod(String value) &#123; Log.d(Tag, &quot;匿名类参数修改：get：&quot; + value); &#125; &#125;);-------------------------------------------------------------------XposedHelpers.findAndHookMethod(&quot;com.xxxxxx.HookDemo$1&quot;, clazz.getClassLoader(), &quot;clasNameMethod&quot;,String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = &quot;匿名类-参数修改&quot;; &#125; &#125;);-------------------------------------------------------------------执行结果：D/HookDemo: 匿名类参数修改：get：匿名类-参数修改 Hook替换函数123456789101112131415private void repleaceMethod()&#123; getHook(&quot;sfdsfs-afsafsf&quot;);&#125;------------------------------------------------------------------- XposedHelpers.findAndHookMethod(clazz, &quot;repleaceMethod&quot;, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable &#123; try &#123; // 直接替换原来要执行的逻辑代码,目标方法就不在执行了 &#125; catch (Throwable t) &#123; XposedBridge.log(t); &#125; &#125; &#125;); 替换资源IXposedHookZygoteInitHook the initialization of Zygote process(es), from which all the apps are forked. Implement this interface in your module’s main class in order to be notified when Android is starting up. In IXposedHookZygoteInit, you can modify objects and place hooks that should be applied for every app. Only the Android framework/system classes are available at that point in time. Use null as class loader for XposedHelpers.findAndHookMethod(String, ClassLoader, String, Object…) and its variants. If you want to hook one/multiple specific apps, use IXposedHookLoadPackage instead. 替换系统框架资源（对所有app 起作用）需要实现 IXposedHookZygoteInit接口的 initZygote 方法，并在该方法中调用Resources.setSystemWideReplacement(…) 方法替换资源： 12345678public class Tutorial2 implements IXposedHookZygoteInit&#123; @Override public void initZygote(StartupParam arg0) throws Throwable &#123; XResources.setSystemWideReplacement(&quot;android&quot;, &quot;bool&quot;, &quot;config_unplugTurnsOnScreen&quot;, false); &#125;&#125; IXposedHookInitPackageResources替换app应用资源需要实现 IXposedHookInitPackageResources 类的andleInitPackageResources方法，并在该方法中调用res.setReplacement(…)方法替换资源，注意在该方法中不要使用XResources.setSystemWideReplacement 方法: 123456789101112131415161718@Override public void handleInitPackageResources(XC_InitPackageResources.InitPackageResourcesParam resparam) throws Throwable &#123; if (resparam.packageName.equals(&quot;com.example.xposedhooktarget&quot;)) &#123; //getClassInfo(clazz); resparam.res.setReplacement(&quot;com.xxxxxx.xposedhooktarget&quot;, &quot;string&quot;, &quot;action_test&quot;, &quot;HkTargetTest&quot;); resparam.res.setReplacement(&quot;com.example.xposedhooktarget&quot;, &quot;color&quot;, &quot;colorAccent&quot;, R.color.colorPrimary);resparam.res.setReplacement(&quot;2131165219&quot;, &quot;HkTargetTest-action_text&quot;); resparam.res.setReplacement(&quot;com.xxxxxxx.xposedhooktarget&quot;, &quot;mipmap&quot;, &quot;test_icon&quot;, new XResources.DrawableLoader() &#123; @Override public Drawable newDrawable(XResources res, int id) throws Throwable &#123; Drawable dg = res.getDrawable(R.mipmap.ic_launcher); return dg; &#125; &#125;); &#125; &#125; 还可以替换动画文件等等。 修改布局12345678910111213141516resparam.res.hookLayout(&quot;com.xxxxxx.xposedhooktarget&quot;, &quot;layout&quot;, &quot;activity_main&quot;, new XC_LayoutInflated() &#123; @Override public void handleLayoutInflated(LayoutInflatedParam liparam) throws Throwable &#123; //增加一个TextView FrameLayout contentview = (FrameLayout) liparam.view; if (contentview != null) &#123; TextView textView = new TextView(contentview.getContext()); textView.setText(&quot;修改布局&quot;); contentview.addView(textView); &#125; //修改@+id= bt_text1 的TextView的文案 TextView bt_text1 = (TextView) liparam.view.findViewById( liparam.res.getIdentifier(&quot;bt_text1&quot;, &quot;id&quot;, &quot;com.xxxxxx.xposedhooktarget&quot;)); bt_text1.setText(&quot;修改布局文本&quot;); &#125; &#125;); 群控需求：被动添加好友。 要求：采用静默的无感知模式。 实现：思路，采用hook添加好友协议的模式，入口在db的hook基础上进行监听验证好友的请求，因为不论什么信息，都会首先会存储与微信的db中。 前提：已经hook了界面的跳转，和打开了微信的log信息。详细点击. 过程：在前提下，我们可以得到了三个关于被动添加好友的信息： 1、好友通过验证的界面名称和传递的参数。 123456789101112131415E/hotWeixinHook: ActivityHook; activity=com.tencent.mm.plugin.profile.ui.SayHiWithSnsPermissionUI@a3b6b62, onCreate; getIntent()=Intent &#123; cmp=com.tencent.mm/.plugin.profile.ui.SayHiWithSnsPermissionUI (has extras), extra=bundle&#123; sayhi_with_sns_perm_send_verify=true, room_name=null, source_from_user_name=null, sayhi_with_sns_perm_add_remark=true, source_from_nick_name=null, Contact_Nick=大王, Contact_User=v1_841761d9ad2fee00bafee3e6c65ec45aef0c541d5c3bacfc2d24acd30fe184f31cd28a41808180cfff4ebd0325d4a1a1@stranger, Contact_Scene=15, Contact_RemarkName=, =false, AntispamTicket=v2_6e521f51ae39720c3154a79ba26c689efab115f39b314795f803a2889d76a013e05b3569cdd1f5328da35803ed134968@stranger &#125; &#125;, bundle=bundle&#123;&#125; 2、验证的详细信息 12345678910111213141516171819MicroMsg.FMessageProvider; setDigest, fmsgType = 1, fmsgScene = 30, fmsgContent = &lt;msg fromusername=&quot;aibhyi1314521&quot; encryptusername=&quot;v1_4bb4022da882fa9b480543b3a0e48fcc76b5530d371c9defe34a653497843e38@stranger&quot; fromnickname=&quot;忘记一切&quot; content=&quot;我是忘记一切&quot; fullpy=&quot;wangjiyiqie&quot; shortpy=&quot;WJYQ&quot; imagestatus=&quot;3&quot; scene=&quot;30&quot; country=&quot;CN&quot; province=&quot;Hebei&quot; city=&quot;Baoding&quot; sign=&quot;带走一盏渔火，让他温暖我的双眼。留下一段真情让他停泊在枫桥边&quot; percard=&quot;1&quot; sex=&quot;1&quot; alias=&quot;wuluqi0606&quot; weibo=&quot;&quot; albumflag=&quot;0&quot; albumstyle=&quot;0&quot; albumbgimgid=&quot;&quot; snsflag=&quot;17&quot; snsbgimgid=&quot;http://shmmsns.qpic.cn/mmsns/CttmTaYSYkS6fvUyDJs0icQ6oRUqibtDIuUylCkHeRHfk4jF7nToTbSYAm5H0z84qh9fHACkovW1c/0&quot; snsbgobjectid=&quot;12854304281324228767&quot; mhash=&quot;3140af8c3cd25f8db0eaa8815cc2cd95&quot; mfullhash=&quot;3140af8c3cd25f8db0eaa8815cc2cd95&quot; bigheadimgurl=&quot;http://wx.qlogo.cn/mmhead/ver_1/qKwkYHXZa7iahrsJ2DV7NhuZnrWft9icLTiculKSTJiaJVQvpMPV1dyKH9HuqM3F9picnfZ6dd1ujxxCADH0tHburXhYQBsSP0ZQbD8USaqzXh7c/0&quot; smallheadimgurl=&quot;http://wx.qlogo.cn/mmhead/ver_1/qKwkYHXZa7iahrsJ2DV7NhuZnrWft9icLTiculKSTJiaJVQvpMPV1dyKH9HuqM3F9picnfZ6dd1ujxxCADH0tHburXhYQBsSP0ZQbD8USaqzXh7c/96&quot; ticket=&quot;v2_e57f9519b15cab7743fe81feced778340c7cb4a2c6cbbb361fdd606bbf815478db4e967568ece4fbf27519726dda64492f68992a4e750ef8e4e6e72724f075e8@stranger&quot; opcode=&quot;2&quot; googlecontact=&quot;&quot; qrticket=&quot;&quot; chatroomusername=&quot;&quot; sourceusername=&quot;&quot; sourcenickname=&quot;&quot;&gt;&lt;brandlist count=&quot;0&quot; ver=&quot;685330891&quot;&gt;&lt;/brandlist&gt;&lt;/msg&gt;, isSend = false 3、存储数据库名称。 MicroMsg.SDK.MAutoStorage; fmessage_conversation:get with primary key 4、根据1得到的界面，我们可以查看微信的逆向代码。我是用的jadx-0.7.2，不要用jadx低版本，因为低版本的逆向结果的代码中，不含有我们需要hook的具体类名和方法名。因为微信的包比较大，我们最好把逆向代码导出来，使用的时候用AS打开即可。 5、我们看下点击发送按钮等源代码：（比较长，但是不贴一下，没法说啊） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class C305316 implements OnMenuItemClickListener &#123; C305316() &#123; &#125; public final boolean onMenuItemClick(MenuItem menuItem) &#123; final C1138k c8233f; SayHiWithSnsPermissionUI sayHiWithSnsPermissionUI; Context context; if (SayHiWithSnsPermissionUI.this.f97358pqM) &#123; int i; List linkedList = new LinkedList(); linkedList.add(SayHiWithSnsPermissionUI.this.userName); List linkedList2 = new LinkedList(); linkedList2.add(Integer.valueOf(SayHiWithSnsPermissionUI.this.f97352pnn)); String g = SayHiWithSnsPermissionUI.m63520g(SayHiWithSnsPermissionUI.this); Map hashMap = new HashMap(); if (SayHiWithSnsPermissionUI.this.f97357pqL.f28645zEk) &#123; i = 1; &#125; else &#123; i = 0; &#125; hashMap.put(SayHiWithSnsPermissionUI.this.userName, Integer.valueOf(i)); C6159x.m11666d(&quot;MicroMsg.SayHiWithSnsPermissionUI&quot;, &quot;select sns permission, %s&quot;, Integer.valueOf(i)); if (C10044x.m20844Xg(SayHiWithSnsPermissionUI.this.userName)) &#123; c8233f = new C8233f(SayHiWithSnsPermissionUI.this.userName, g, SayHiWithSnsPermissionUI.this.getIntent().getStringExtra(C32536a.f104548xML)); C32688as.m69428CN().mo13442a(c8233f, 0); sayHiWithSnsPermissionUI = SayHiWithSnsPermissionUI.this; context = SayHiWithSnsPermissionUI.this.mController.f28409xRr; SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f8616dGZ); sayHiWithSnsPermissionUI.f97348inI = C36199h.m82220a(context, SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f10212eKs), true, new OnCancelListener() &#123; public final void onCancel(DialogInterface dialogInterface) &#123; C32688as.m69428CN().mo13446c(c8233f); &#125; &#125;); &#125; else &#123; final C1138k c31589o = new C31589o(2, linkedList, linkedList2, g, &quot;&quot;, hashMap, SayHiWithSnsPermissionUI.this.chatroomName); String stringExtra = SayHiWithSnsPermissionUI.this.getIntent().getStringExtra(&quot;source_from_user_name&quot;); String stringExtra2 = SayHiWithSnsPermissionUI.this.getIntent().getStringExtra(&quot;source_from_nick_name&quot;); if (!C6135bi.m11498oN(stringExtra)) &#123; c31589o.mo40569fj(stringExtra, stringExtra2); &#125; C32688as.m69428CN().mo13442a(c31589o, 0); SayHiWithSnsPermissionUI sayHiWithSnsPermissionUI2 = SayHiWithSnsPermissionUI.this; context = SayHiWithSnsPermissionUI.this.mController.f28409xRr; SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f8616dGZ); sayHiWithSnsPermissionUI2.f97348inI = C36199h.m82220a(context, SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f10212eKs), true, new OnCancelListener() &#123; public final void onCancel(DialogInterface dialogInterface) &#123; C32688as.m69428CN().mo13446c(c31589o); &#125; &#125;); &#125; &#125; else if (SayHiWithSnsPermissionUI.this.f97359pqN) &#123; String stringExtra3 = SayHiWithSnsPermissionUI.this.getIntent().getStringExtra(&quot;Verify_ticket&quot;); if (C10044x.m20844Xg(SayHiWithSnsPermissionUI.this.userName)) &#123; c8233f = new C8234g(SayHiWithSnsPermissionUI.this.userName, stringExtra3); C32688as.m69428CN().mo13442a(c8233f, 0); sayHiWithSnsPermissionUI = SayHiWithSnsPermissionUI.this; context = SayHiWithSnsPermissionUI.this.mController.f28409xRr; SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f8616dGZ); sayHiWithSnsPermissionUI.f97348inI = C36199h.m82220a(context, SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f9343dUY), true, new OnCancelListener() &#123; public final void onCancel(DialogInterface dialogInterface) &#123; C32688as.m69428CN().mo13446c(c8233f); &#125; &#125;); &#125; else &#123; c8233f = new C31589o(SayHiWithSnsPermissionUI.this.userName, stringExtra3, SayHiWithSnsPermissionUI.this.f97352pnn); C32688as.m69428CN().mo13442a(c8233f, 0); sayHiWithSnsPermissionUI = SayHiWithSnsPermissionUI.this; context = SayHiWithSnsPermissionUI.this.mController.f28409xRr; SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f8616dGZ); sayHiWithSnsPermissionUI.f97348inI = C36199h.m82220a(context, SayHiWithSnsPermissionUI.this.getString(C1085R.C1081l.f9343dUY), true, new OnCancelListener() &#123; public final void onCancel(DialogInterface dialogInterface) &#123; C32688as.m69428CN().mo13446c(c8233f); &#125; &#125;); &#125; &#125; return false; &#125; &#125; 经过一系列判断，我们最终最后定位到通过协议的代码C32688as.m69428CN().mo13442a(c8233f, 0);为啥啊，因为不管是if和else if的的条件我们都能够拿到，怎么拿到，我们可以通过XposedHelpers.getObjectField(param.thisObject, “方法变量”);获得到f97359pqN和f97358pqM的值；然后我们看C32688as这个类： 12345678/* renamed from: com.tencent.mm.y.as */public final class C32688as &#123; /* renamed from: CN */ public static C7656n m69428CN() &#123; C1693g.m4270Dr(); return C1693g.m4268Dp().f13865gRu; &#125;&#125; 再看C7656n调用类：好吧只看mo13442a这一个方法就行了，这个就是通过好友的开始方法了； 1234567891011121314151617181920/* renamed from: com.tencent.mm.ad.n */public final class C7656n implements C1125e &#123; /* renamed from: a */ public final boolean mo13442a(C1138k c1138k, int i) &#123; boolean z = c1138k != null || i &gt;= 0; Assert.assertTrue(z); String str = &quot;worker thread has not been set&quot;; if (this.f30978hoG != null) &#123; z = true; &#125; else &#123; z = false; &#125; Assert.assertTrue(str, z); if (!m15236e(c1138k)) &#123; return false; &#125; m15231b(c1138k, i); return true; &#125;&#125; 我们在看请求的参数：一个类C31589o，好吧，看出来了，就是一个model类。 123/* renamed from: com.tencent.mm.pluginsdk.model.o */public class C31589o extends C1138k implements C1865k &#123;&#125; 综上：我们可以得到最终的静默实现好友验证请求通过了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override public void onUpdate(Object database, String path, String table, ContentValues values, String whereClause, String[] whereArgs, int conflictAlgorithm) &#123; if (DBConstants.MicroMsg.Fmessage_Conversation.TABLE_NAME.equals(table)) &#123; Integer isNew = values.getAsInteger(DBConstants.MicroMsg.Fmessage_Conversation.COLUMN_isNew); String talker = values.getAsString(DBConstants.MicroMsg.Fmessage_Conversation.COLUMN_talker); Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; parseRequestContent;isNew.&quot;+isNew); // isNew == 1:新好友请求 if (isNew != null &amp;&amp; isNew == 1) &#123; try &#123; String fmsgContent = values.getAsString(DBConstants.MicroMsg.Fmessage_Conversation.COLUMN_fmsgContent); Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; parseRequestContent;fmsgContent.&quot;+fmsgContent); JSONObject jsonObject = new XmlToJson.Builder(fmsgContent).build().toJson(); JSONObject appMsg = jsonObject.getJSONObject(&quot;msg&quot;); if (fmsgContent == null) &#123; Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; parseRequestContent; appMsg is null, just return.&quot;); return; &#125; Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; &amp;wxid:=&quot; + appMsg.getString(&quot;fromusername&quot;) + &quot;&amp;ticket:&quot; + appMsg.getString(&quot;ticket&quot;) + &quot;&amp;scene:&quot; + appMsg.getInt(&quot;scene&quot;)); int state = Utils.getFCState(talker); Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; state1:&quot;+state); if(state == 1)&#123; report(appMsg.getString(&quot;fromusername&quot;).toString(), appMsg.getString(&quot;fromnickname&quot;).toString(), appMsg.getString(&quot;content&quot;).toString() ); &#125;else&#123; final Object instance_y_as_cn = XposedHelpers.callStaticMethod( XposedHelpers.findClass(&quot;com.tencent.mm.y.as&quot;, mWeixinHook.getClassLoader()), &quot;CN&quot; ); String username = appMsg.getString(&quot;fromusername&quot;).toString(); String ticket = appMsg.getString(&quot;ticket&quot;).toString(); int scene = appMsg.getInt(&quot;scene&quot;); Class&lt;?&gt; class_model_o = XposedHelpers.findClass(&quot;com.tencent.mm.pluginsdk.model.o&quot;, mWeixinHook.getClassLoader()); Object request = XposedHelpers.newInstance(class_model_o, username, ticket, scene); Object result = XposedHelpers.callMethod(instance_y_as_cn, &quot;a&quot;, request, 0); Log.e(WeixinHook.TAG, &quot;DBEventReceiveFriendsVerify; result; &quot; + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 测试一下，搞定。 参考资源https://api.xposed.info/reference/packages.html https://bintray.com/rovo89/de.robv.android.xposed/api http://www.infoq.com/cn/articles/android-in-depth-xposed https://blog.csdn.net/u012417380/article/details/55254369?locationNum=13&amp;fps=1 https://www.cnblogs.com/gordon0918/p/6732100.html","categories":[{"name":"Android","slug":"Android","permalink":"http://nunu03.github.io/categories/Android/"}],"tags":[{"name":"Xposed","slug":"Xposed","permalink":"http://nunu03.github.io/tags/Xposed/"}]},{"title":"MIUI权限检测之路","slug":"permissioncheck","date":"2019-07-02T05:12:26.000Z","updated":"2019-07-02T13:09:42.000Z","comments":true,"path":"2019/07/02/permissioncheck/","link":"","permalink":"http://nunu03.github.io/2019/07/02/permissioncheck/","excerpt":"问题与需求在业务线在使用过程中，发生了一些权限状态丢失的情况。而在我们的群控平台中，如果某些权限的设置状态丢失，则群控平台绝大多数功能不能执行。尤其是HRG业务人员，它们不仅需要群控自动执行功能指令，还不能影响手动操作。所以在权限状态丢失后，产品提出了一个权限检测的需求。这个需求就是在我们的平台中检测应用的权限列表，获取权限的当前状态。用于提示使用者，当前的群控在权限设置上是否已经被允许。","text":"问题与需求在业务线在使用过程中，发生了一些权限状态丢失的情况。而在我们的群控平台中，如果某些权限的设置状态丢失，则群控平台绝大多数功能不能执行。尤其是HRG业务人员，它们不仅需要群控自动执行功能指令，还不能影响手动操作。所以在权限状态丢失后，产品提出了一个权限检测的需求。这个需求就是在我们的平台中检测应用的权限列表，获取权限的当前状态。用于提示使用者，当前的群控在权限设置上是否已经被允许。 权限介绍一个Android应用默认情况下是不拥有任何权限的, 在默认情况下, 一个应用是没有权利去进行一些可能会造成不好影响的操作的. 这些不好的影响可能是对其它应用,操作系统,或者是用户.如果应用需要某些额外的能力,则需要在AndroidManifest.xml中静态地声明相应的权限.也就是我们在AndroidManifest.xml注册了一系列uses-permission，这些permission就是我们需要申请的权限。 在Android 6.0发布之前, 所有的权限都在安装应用的时候显示给用户,用户选择安装则表示全部接受这些权限, 之后无法撤销对这些权限的授权.但是从Android 6.0开始, 一部分比较危险的权限需要在程序运行请求用户授权.至于什么时候需要授权,由应用程序自己决定.而这些权限，就是我们所说的运行时权限。而对于其他权限,认为不是很危险,所以仍然保持原来的做法,在用户安装应用程序时就予以授权.需要注意的是,在设置中,对于应用的危险权限,用户可以选择性地进行授权或者关闭. Dangerous Permissions主要有： Permission GroupPermissions CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORAGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 而通过上述危险权限来看，是有了组的概念，只要我们授权了其中一个权限，那就授权当前组的所有全新啊。而我们可以通过下面的方法获取到所有的申请权限： 123PackageManager packageManager = this.getPackageManager();PackageInfo packageInfo =packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);String[] usesPermissionsArray = packageInfo.requestedPermissions; 实现历程1.App OpsGoogle在SDK19中引入了AppOps的权限管理方式，AppOpsManager是对外的管理接口，真正实现功能的是AppOpsService。AppOpsManager里面有两个比较重要的方法: 12AppOpsManager::checkOp(int op ,int uid ,String packageName) （hide方法)AppOpsManager::checkOp(String op,int uid ,String packageName)（public方法） 所以我们可以用第二个方式检测权限的状态，uid和packageName我们可以拿到，但是op是什么呢，通过查找我们发现AppOpsManager提供了一个函数permissionToOp，通过这个函数我们可以，我们可以把标题1中获取到的uses-permission转换成op，然后我们就可以利用checkOp获取到权限的状态结果了。但是在实际的操作中我们发现。发生了一个SecurityException异常。这个是为什么呢，我们通过查看源码发现。permissionToOp可能为空，这个是因为，我们标题1中获取到的permission，不一定有对应的op值。部分展示如下所示：我们发现其中有好多null值。 12345678910111213141516171819202122232425262728/** * This maps each operation to the public string constant for it. * If it doesn&apos;t have a public string constant, it maps to null. */private static String[] sOpToString = new String[] &#123; OPSTR_COARSE_LOCATION, OPSTR_FINE_LOCATION, null, null, OPSTR_READ_CONTACTS, OPSTR_WRITE_CONTACTS, OPSTR_READ_CALL_LOG, ......, ......, ......, ......, ......, null, OPSTR_USE_FINGERPRINT, OPSTR_BODY_SENSORS, OPSTR_READ_CELL_BROADCASTS, OPSTR_MOCK_LOCATION, OPSTR_READ_EXTERNAL_STORAGE, OPSTR_WRITE_EXTERNAL_STORAGE, null, OPSTR_GET_ACCOUNTS, null,&#125;; 结论： 1、通过permissionToOp和checkOp将不能满足我们的需求。 2、我们发现AndroidManifest.xml中的权限要比小米手机权限列表中的要多。 2.SecurityCenterSecurityCenter是什么，它是小米手机权限管理的apk，通过反编译，我们可以一步步的发现小米手机获取权限列表状态的实现方式。粘一下小米的实现核心代码： 123456789101112131415161718192021222324252627282930313233343536373839public PermissionList loadInBackground() &#123; PermissionList permissionList = new PermissionList(); permissionList.isEnabled = isEnabled(); HashMap cB = packagePermisson(this.mContext, packageName); ArrayList&lt;PermissionBean&gt; arrayList = new ArrayList(); permissionList.hashMap = cB; permissionList.PermissionBeanList = arrayList; if (cB != null) &#123; Iterable&lt;PermissionGroupInfo&gt; boo = mo5980boo(0); Iterable&lt;PermissionInfo&gt; bop = mo5981bop(0); Set keySet = cB.keySet(); HashMap hashMap = new HashMap(); for (PermissionGroupInfo permissionGroupInfo : boo) &#123; PermissionBean permissionBean = new PermissionBean(); permissionBean.permissionGroupInfo = permissionGroupInfo; hashMap.put(Integer.valueOf(permissionGroupInfo.getId()), permissionBean); arrayList.add(permissionBean); &#125; for (PermissionInfo permissionInfo : bop) &#123; if (keySet.contains(Long.valueOf(permissionInfo.getId()))) &#123; PermissionBean permissionBean2 = (PermissionBean) hashMap.get(Integer.valueOf(permissionInfo.getGroup())); if (permissionBean2 != null) &#123; permissionBean2.permissionInfoArrayList.add(permissionInfo); &#125; &#125; &#125; ArrayList&lt;PermissionBean&gt; arrayList2 = new ArrayList(); for (PermissionBean permissionBean3 : arrayList) &#123; if (permissionBean3.permissionInfoArrayList.size() == 0) &#123; arrayList2.add(permissionBean3); &#125; &#125; for (PermissionBean permissionBean32 : arrayList2) &#123; arrayList.remove(permissionBean32); &#125; &#125; return permissionList; &#125; 其中，packagePermisson，mo5980boo，mo5981bop，都是通过ContentResolver跨进程获取到的，然后把获取到的权限分组拼装即可。所以，通过这种方式，我们获取到的权限状态和小米手机的权限列表是一致的。 结论： 因为上述实现是基于note 4x手机的安全中心获取的，所以没有问题。但是我们的手机型号不止是4x手机，还有其他小米手机，但我在其他手机上运行的时候，发现报错，出现没有miui.permission.READ_AND_WIRTE_PERMISSION_MANAGER的异常。所以，这种实现方式，不能支撑所有手机。 3.AppOpsX是一个第三方权限管理的实现，通过调用appops的权限管理器，控制权限管理。[Github:https://github.com/8enet/AppOpsX] (https://github.com/8enet/AppOpsX),接入AppOpsX后，可以支撑所有小米手机，但是获取到的权限列表不能和小米手机的权限中心一致，这个会导致产品和运营有一定的误解，并且接入比较困难，可能对今天版本的兼容也会有问题。 4.checkSelfPermissionContextCompatAndroid 6.0 变更:此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。 对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 checkSelfPermission() 方法。要请求权限，请调用新增的 requestPermissions() 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。 如需了解有关在您的应用中支持新权限模式的详情，请参阅使用系统权限。如需了解有关如何评估新模式对应用的影响的提示，请参阅权限最佳做法。 ![checkSelfPermission](https://github.com/YlJava110/photo/blob/master/pms/20181124152335.png?raw=true)从上图可知，最终的check会到PackageManagerService. checkComponentPermission,而checkComponentPermission最终调用了 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic int checkUidPermission(String permName, int uid) &#123; final int userId = UserHandle.getUserId(uid); if (!sUserManager.exists(userId)) &#123; return PackageManager.PERMISSION_DENIED; &#125; synchronized (mPackages) &#123; Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid)); if (obj != null) &#123; final SettingBase ps = (SettingBase) obj; final PermissionsState permissionsState = ps.getPermissionsState(); if (permissionsState.hasPermission(permName, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; // Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; permissionsState .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; else &#123; ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid); if (perms != null) &#123; if (perms.contains(permName)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; perms .contains(Manifest.permission.ACCESS_FINE_LOCATION)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; &#125; &#125; return PackageManager.PERMISSION_DENIED;&#125; 这里最重要的就是mSettings，所有的权限信息都通过mSettings来获取，但是mSettings是都做了什么操作呢？看下边的图： Android6.0之前会吧所有的权限都放置在data/system/packages.xml文件中。Android6.0之后，分为运行时权限跟普通权限，普通权限还是放在data/system/packages.xml中，运行时权限防止在data/system/users/0/runtime-permissions.xml文件中。根据运行时是否动态申请去更新权限。而对于普通权限，一直都为true。具体的实例信息如下： packages.xml 1234567891011&lt;package name=&quot;com.permisison.naga&quot; codePath=&quot;/data/app/com.wuba.tinyhand-2&quot; nativeLibraryPath=&quot;/data/app/com.wuba.tinyhand-2/lib&quot; primaryCpuAbi=&quot;armeabi&quot; publicFlags=&quot;944291398&quot; privateFlags=&quot;0&quot; ft=&quot;166817e48c8&quot; it=&quot;16615425c49&quot; ut=&quot;166817e51fc&quot; version=&quot;2540&quot; userId=&quot;10141&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;11&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.WRITE_SETTINGS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.RESTART_PACKAGES&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;28&quot; /&gt; &lt;/package&gt; runtime-permissions.xml 12345678&lt;pkg name=&quot;com.permisison.naga&quot;&gt; &lt;item name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; granted=&quot;true&quot; flags=&quot;2&quot; /&gt; &lt;item name=&quot;android.permission.READ_PHONE_STATE&quot; granted=&quot;true&quot; flags=&quot;2&quot; /&gt; &lt;item name=&quot;android.permission.SEND_SMS&quot; granted=&quot;false&quot; flags=&quot;2&quot; /&gt; &lt;item name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot; granted=&quot;true&quot; flags=&quot;2&quot; /&gt; &lt;item name=&quot;android.permission.GET_ACCOUNTS&quot; granted=&quot;true&quot; flags=&quot;2&quot; /&gt; &lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;2&quot; /&gt; &lt;/pkg&gt; 结论： 1、checkSelfPermission会分别判断两个xml文件，packages.xml是普通权限，并且一直返回true，runtime-permissions.xml返回的是动态权限的状态，会根据当前设置返回0和-1，0是授予，-1是未被授予权限。 2、国内手机厂商的rom都是修改过了，并且增加了不少自定义的权限，所以这个方法获取的结果是不全的。 PermissionChecker直接看下关键代码： 1234567891011121314151617181920212223242526public static int checkPermission(@NonNull Context context, @NonNull String permission, int pid, int uid, String packageName) &#123; if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) &#123; return PERMISSION_DENIED; &#125; String op = AppOpsManagerCompat.permissionToOp(permission); if (op == null) &#123; return PERMISSION_GRANTED; &#125; if (packageName == null) &#123; String[] packageNames = context.getPackageManager().getPackagesForUid(uid); if (packageNames == null || packageNames.length &lt;= 0) &#123; return PERMISSION_DENIED; &#125; packageName = packageNames[0]; &#125; if (AppOpsManagerCompat.noteProxyOp(context, op, packageName) != AppOpsManagerCompat.MODE_ALLOWED) &#123; return PERMISSION_DENIED_APP_OP; &#125; return PERMISSION_GRANTED;&#125; 里面有这么一句判断 1234String op = AppOpsManagerCompat.permissionToOp(permission);if (op == null) &#123; return PERMISSION_GRANTED; &#125; AppOpsManager返回为null的permission，都返回PERMISSION_GRANTED=0；这个判断就不准确了，如果一个运行时权限，没有在这个里面，那就永远为o了。即使设置了拒绝，也获取不到PERMISSION_DENIED=1。并且，小米手机设置好多10000以上都op自定义权限，肯定是获取不到，并且有些权限还没有permission。 结论：完全不可用。继续尝试 5.AuthManager通过上述一些列的验证，都是不可以采用的结论。最终我们再次回到note 4x的实现方案上来。由于再标题2的时候，我们只是调研了获取权限状态的方式，但是没有深入的调研底层实现。所以我们通过一些列跟踪，最终找到具体的实现地方在AuthManager这个app下。结论： 1、由上图可以看出，小米手机完全自己封装了一层权限管理，它的权限状态都存储在了miui_ngen.db数据库里，并且通过PermissionManager管理并定义了权限的op和android.permission值。 2、既然update时完全操作了db和xml三个文件。那我们是不是可以用反射的方法实现呢？经过实现，利用反射checkOpNoThrow虽然可以获取到具体状态值，但是我们只能获取到当前的权限，不能获取到第三方app的权限，报java.lang.SecurityException: uid 10141 does not have android.permission.UPDATE_APP_OPS_STATS异常。 3、开发过程中，发现某些运行权限op=59的权限不能改变，一致获取到的是0.即授权的状态。所以利用反射我们也不能实现我们的需求，继续。 6.runtime-permissions.xml与appops.xml经过调研后发现，当我们在修改权限的状态值时，不仅appops.xml里面的状态值在该比那，而且运行权限runtime-permissions.xml的值也在改变，那我们是不是可以比较两个文件的内容进行获取状态值呢。 首先，我们需要读取文件，但是我们没有读取文件权限，我们需要copy到sdcard进行解析。解析过程如下图： 7.miui_ngen.dbmiui_ngen.db是什么？我们都知道是一个数据库文件，而且这个是miui的权限状态管理文件。任何的App权限状态都一一对应的存在了这个文件里。从而由上述6种的操作，我们受到了一定的启发，既然能够拿到xml文件，那我们是不是也可以直接拿到这个db文件，然后直接读取db，获取状态信息呢？经过尝试，好吧，权限检测的最终方案决定下来了，我们完全可以直接读取这个db文件，获取到准确的，和miui权限管理中心一一对应，完全匹配的权限状态。 总结：通过以上步骤的实现过程，我们发现由于国内厂商对rom的定制，可能完全修改或者封装了权限的实现和检测机制，我们通过一步步的测试和添坑，最终还是回到了手机原本自身的检测机制上来，并且这种方式是最准确的方式。 对权限的处理场景如果设备运行的是 Android 6.0（API 级别 23）或更高版本，并且应用的 targetSdkVersion 是 23 或更高版本，则应用在运行时向用户请求权限。用户可随时调用权限，因此应用在每次运行时均需检查自身是否具备所需的权限。 如果设备运行的是 Android 5.1（API 级别 22）或更低版本，并且应用的 targetSdkVersion 是 22 或更低版本，则系统会在用户安装应用时要求用户授予权限。如果将新权限添加到更新的应用版本，系统会在用户更新应用时要求授予该权限。用户一旦安装应用，他们撤销权限的唯一方式是卸载应用。 如果设备运行的是 Android 6.0（API 级别 23）或更高版本，并且应用的 targetSdkVersion 是 22 或更低版本， 此时Android系统会把你申请的全部权限都给你 。 用户依然可以进入App的设置界面把权限关闭 ！ 参考资料https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn#behavior-runtime-permissionshttps://blog.csdn.net/lewif/article/details/49124757https://blog.csdn.net/happylishang/article/details/53813779https://mp.weixin.qq.com/s/OQRHEufCUXBA3d3DMZXMKQhttps://developer.android.com/reference/android/support/v4/content/ContextCompat#checkSelfPermission(android.content.Context,%20java.lang.String)https://developer.android.com/reference/android/content/pm/PackageManager#PERMISSION_DENIEDhttps://www.jianshu.com/p/0ddd129dd32bhttps://blog.csdn.net/happylishang/article/details/78222788https://www.cnblogs.com/neo-java/p/7117482.html","categories":[{"name":"Android","slug":"Android","permalink":"http://nunu03.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://nunu03.github.io/tags/Android/"}]},{"title":"Kotlin新手使用笔记","slug":"kotlinnotes","date":"2019-07-02T03:44:51.000Z","updated":"2019-07-04T08:04:50.000Z","comments":true,"path":"2019/07/02/kotlinnotes/","link":"","permalink":"http://nunu03.github.io/2019/07/02/kotlinnotes/","excerpt":"const关键字只读属性使用const关键字之后将没有get方法，举个例子在kotlin文件中，写两个包级属性，一个是const，一个不是const 12const val i = 1val j = &quot;A&quot;","text":"const关键字只读属性使用const关键字之后将没有get方法，举个例子在kotlin文件中，写两个包级属性，一个是const，一个不是const 12const val i = 1val j = &quot;A&quot; 使用java代码访问，访问方式是不同的 123456public class TestConst &#123; public static void main(String[] args) &#123; int i = ConstKt.i; ConstKt.getJ(); &#125;&#125; 一种是使用get方法访问，一种是直接使用类访问。说明const关键字实际上相当于java的static final。需要注意的是，Const只能是kotlin的string和基本类型。其实在object中const相当于@JvmField注解，比如下面的代码 12@JvmFieldval c = 3 就和 1const val c = 3 效果一样 123456789@JvmFieldval TAGS = WeixinHook.TAG + &quot;.Test&quot;const val TAGSG = WeixinHook.TAG + &quot;.Test&quot; @NotNull@JvmFieldpublic static final String TAGS = &quot;hotB.wechat.Test&quot;;@NotNullpublic static final String TAGSG = &quot;hotB.wechat.Test&quot;; 在class中 123456789private const val TAG = XLog.hotPanel + &quot;DeviceUtil&quot;class DeviceUtil&#123;&#125;生成了另一个文件存储constpublic final class DeviceUtilKt &#123; /* renamed from: MB */ private static final long f14MB = 1048576; private static final String TAG = &quot;hotPanel.DeviceUtil&quot;;&#125; 这就是kotlin中const关键字的本质。原文点击 静态内部类，常量，三元运算符静态内部变量和常量定义方法 1234companion object &#123; private const val MSG_UPDATE_PROGRESS = 1 private const val MSG_UPDATE_TIME= 1000 &#125; 静态内部类 1234567class Parent&#123; class Child //默认就是 java的 public static&#125;fun main(args: Array&lt;String&gt;) &#123; val inner = Parent.Child() &#125; 非静态内部类 1234567class Parent&#123; //非静态内部类声明 inner class Child&#125;fun main(args: Array&lt;String&gt;) &#123; val inner = Parent().Child()&#125; 内部类访问外部持有类的this 12345678910111213class Parent&#123; val a:Int = 0 inner class Child&#123; val a:Int = 5 fun hello()&#123; println(this@Parent.a) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val inner = Parent().Child() inner.hello()&#125; 三元运算符 1234 //Java写法int size=list!=null?list.size:0//kotlin写法val size=if(list!=null) list.size() else 0 原文点击 readLine赋值为空Java中有一个判断是 1if（（str=bufferedReader.readLine()）!= null） 这句话到了kotlin转不过来,java经过强制转换成kotlin，可能最初我们是这么写的 1234var str=bufferedReader.readLine() while(str != null)&#123; 执行代码 &#125; 可是出oom了，问题在哪呢？不说了。最后 12345var line: Stringwhile (true) &#123; line = bufferedReader.readLine() ?: break buffer.append(line)&#125; 属性val:val属性只提供getter 1234567val usbState: UsbState get() = sUsbState.copy()编译后的：@NotNullpublic final UsbState getUsbState() &#123; return UsbMonitor.sUsbState.copy();&#125; var：默认生成getter，setter方法 12345678var usbConnected: Boolean = falsepublic final boolean getUsbConnected() &#123; return this.usbConnected;&#125;public final void setUsbConnected(boolean &lt;set-?&gt;) &#123; this.usbConnected = &lt;set-?&gt;;&#125; 对象表达式 &amp;&amp; 对象声明 &amp;&amp; 伴生对象123456789101112131415161718192021222324252627282930313233343536373839404142434445var btn: Button = findViewById(R.id.btn)// 对象表达式实现匿名内部类btn.setOnClickListener(object: View.OnClickListener &#123; override fun onClick(v: View?) &#123; text.setText(&quot;$&#123;text.text&#125; $&#123;++clickTime&#125;&quot;) &#125;&#125;)// OnClickListener是函数式接口，可使用Lambda表达式btn.setOnClickListener &#123; view -&gt; text.setText(&quot;$&#123;text.text&#125; $&#123;++clickTime&#125;&quot;)&#125;// 对象声明---单例object FoodManager &#123; var foods: MutableList&lt;String&gt; init&#123; foods = mutableListOf&lt;String&gt;() // 初始化食物池 for (i in 1..9) &#123; foods.add(&quot;food$&#123;i&#125;&quot;) &#125; &#125;&#125;var foods = FoodManager.foods // 使用对象声明// 伴生对象---静态成员interface Outputable&#123; fun output(msg: String)&#125;class MyClass&#123; // 定义的MyClass的伴生对象 companion object: Outputable&#123; val name = ”name属性值” //重写父接口中的抽象方法 override fun output(msg: String) &#123; for(i in 1..6)&#123; println (”&lt;h$(i&#125;&gt;$&#123; msg&#125;&lt;/h$&#123;i&#125;&gt;”) &#125; &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; // 调用伴生对象里的方法与属性，与调用静态成员一样 MyClass.output(&quot;fkit.org&quot;) println(MyClass.name)&#125; 对象声明定义常量123456789101112131415161718object NetUtils &#123; /** * 移动 */ const val PROVIDER_TYPE_MOVE = 1 /** * 联通 */ const val PROVIDER_TYPE_UNICOM = 2 /** * 电信 */ const val PROVIDER_TYPE_TELECOM = 3 val NET_TYPE_MOVE = &quot;10086&quot; val NET_TYPE_UNICOM = &quot;10010&quot; val NET_TYPE_TELECOM = &quot;10001&quot;&#125; 由于对象声明定义的数据单例，所以一般调用(.java)都会用Class.INSTANCE.getXXXX，(kotlin)会用Class.XXXX，但是如果对象中声明的是const常量，则只能用Class.XXXX调用。举例说明： 1234567891011121314switch (NetUtils.INSTANCE.providerType(WxVersions.CURRENT_APPLICATION)) &#123; case NetUtils.PROVIDER_TYPE_MOVE: destinationAddress = NetUtils.INSTANCE.getNET_TYPE_MOVE(); break; case NetUtils.PROVIDER_TYPE_UNICOM: destinationAddress = NetUtils.INSTANCE.getNET_TYPE_UNICOM(); break; case NetUtils.PROVIDER_TYPE_TELECOM: destinationAddress = NetUtils.INSTANCE.getNET_TYPE_TELECOM(); break; default: destinationAddress = null; break; &#125; 反编译后的NetUtils 1234567891011121314public final class NetUtils &#123; public static final NetUtils INSTANCE = new NetUtils(); @NotNull private static final String NET_TYPE_MOVE = NET_TYPE_MOVE; @NotNull private static final String NET_TYPE_TELECOM = NET_TYPE_TELECOM; @NotNull private static final String NET_TYPE_UNICOM = NET_TYPE_UNICOM; public static final int PROVIDER_TYPE_MOVE = 1; public static final int PROVIDER_TYPE_TELECOM = 3; public static final int PROVIDER_TYPE_UNICOM = 2; private NetUtils() &#123; &#125; 如果定义的常量没有加const，则在调用的时候要用Class.INSTANCE.getXXXX，但是，这个时候switch，会报constant expression requierd异常。 注意：伴生对象常量定义方式： 123456789101112class MicroMsg &#123; companion object &#123; val DB_NAME = &quot;EnMicroMsg.db&quot; &#125;&#125;而下面这样写法拿不到DB_NAMEclass MicroMsg &#123; val DB_NAME = &quot;EnMicroMsg.db&quot; companion object &#123; &#125;&#125; 伴生对象如何生成public static final 1234567891011class MicroMsg &#123; companion object &#123; val TYPE_IMG = 1 val TYPE_FILE = 2 const val TYPE_VOICE = 3 &#125;&#125;反编译后private static final int TYPE_FILE = 2;private static final int TYPE_IMG = 1;public static final int TYPE_VOICE = 3; constructor构造器123456789101112131.主构造器class MultiTask&lt;TaskData, Result&gt; constructor(private val mTaskItem: TaskItem, private val mRequest: TaskData, private val mTaskCount: Int, private val mDelay: Long = 500) 2.主构造器可以省略constructorclass MultiTask&lt;TaskData, Result&gt; (private val mTaskItem: TaskItem, private val mRequest: TaskData, private val mTaskCount: Int, private val mDelay: Long = 500) 3.主构造器如果有@JvmOverloads则不可以省略constructorclass MultiTask&lt;TaskData, Result&gt; @JvmOverloads constructor(private val mTaskItem: TaskItem, private val mRequest: TaskData, private val mTaskCount: Int, private val mDelay: Long = 500) 4.使用@JvmOverloads注解的主构造器，不可以再有次构造器 constructor(taskItem: TaskItem,mRequest: TaskData,mTaskCount: Int): this(taskItem, mRequest,mTaskCount,300) &#123;&#125;异常，hava the same JVM signature. 构造器几种使用： 12345678910111213141516171819202122232425262728293031323334353637空构造器class OuterConstructor&#123;&#125;私有构造器class OuterConstructor private constructor(str:String, ins:Int)&#123;&#125;私有构造器+次构造器（可调）class OuterConstructor private constructor(str:String, ins:Int)&#123; var s1 = &quot;123&quot; init&#123; this.s1 = str &#125; constructor(str:String):this(str,8)&#125;主构造器class OuterConstructor constructor(str:String, ins:Int)&#123; var s1 = &quot;123&quot; init&#123; this.s1 = str &#125; constructor(str:String):this(str,8)&#125;主构造器省略初始化initclass OuterConstructor &#123; var s1 = &quot;123&quot; init&#123; this.s1 = &quot;qdf&quot; &#125;&#125;主构造器初始化initclass OuterConstructor constructor(str:String, ins:Int)&#123; var s1 = &quot;123&quot; init&#123; this.s1 = str &#125;&#125; @JvmOverloads作用在有默认参数值的方法中使用@JvmOverloads注解，则Kotlin就会暴露多个重载方法。 123456@JvmOverloads fun f(a: String, b: Int=0, c:String=&quot;abc&quot;)&#123;&#125;反编译后：void f(String a)void f(String a, int b)void f(String a, int b, String c) 所以@JvmOverloads不仅仅用于构造方法。 vararg可变参数123456789fun print(vararg msgs: String) &#123; for (msg in msgs) &#123; println(msg) &#125;&#125;fun LogPrinters()&#123; print(&quot;11&quot;,&quot;22&quot;,&quot;33&quot;,&quot;44&quot;);&#125; var get() set(xxx)方法1. 12345override var name: String=&quot;ninhao&quot; get() = field set(value) &#123; field=value&#125; 调用 123XLog.e(&quot;------name1:&quot;,name)name = &quot;henhao&quot;XLog.e(&quot;------name2:&quot;,name) 输出 12ninhaohenhao 注意：var name: String=”ninhao”，必须初始化。2.可以通过fun get() 和fun set(XXX)实现。 3.错误写法：死循环 12345678910111213141516var name: String get() = name set(value) &#123; name=&quot;afff&quot;&#125;反编译后@NotNullpublic String getName() &#123; return getName();&#125;public void setName(@NotNull String value) &#123; Intrinsics.checkParameterIsNotNull(value, UserInfo.COLUMN_value); setName(&quot;afff&quot;);&#125; 详细注解链接 split1234567var sb = StringBuilder()sb.append(&quot;111,&quot;).append(&quot;222,&quot;).append(&quot;333,&quot;).append(&quot;,&quot;).append(&quot;aaa,&quot;).append(&quot;bbb,&quot;).append(&quot;ccc,&quot;).append(&quot;&quot;)val strs = sb.toString()val splits = strs.split(&quot;,&quot;.toRegex()).dropWhile &#123; !it.isEmpty() &#125;.toTypedArray()for(str in splits)&#123; XLog.e(&quot;-------split:&quot;,str)&#125; 1.dropWhile 返回从第一项起，去掉满足条件的元素，直到不满足条件的一项为止；it.isEmpty(): 12345[-------split:][main][-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc[-------split:][main] !it.isEmpty(): 12345678[-------split:][main]111[-------split:][main]222[-------split:][main]333[-------split:][main][-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc[-------split:][main] 2.dropLastWhile 返回从最后一项起，去掉满足条件的元素，直到不满足条件的一项为止；it.isEmpty(): 1234567[-------split:][main]111[-------split:][main]222[-------split:][main]333[-------split:][main][-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc !it.isEmpty(): 12345678[-------split:][main]111[-------split:][main]222[-------split:][main]333[-------split:][main][-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc[-------split:][main] 3.drop 返回去掉前n个元素后的列表；drop(4) 1234[-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc[-------split:][main] 4.filter &amp; slice &amp; take filter–过滤掉所有不满足条件的元素；filterNot–过滤掉所有满足条件的元素；filterNotNull–过滤掉所有值为null的元素； slice–过滤掉非指定下标的元素，即保留下标对应的元素过滤List中指定下标的元素（比如这里只保留下标为1，3，4的元素），当过滤list中有元素值大于目标List大小时会出现异常； take–返回从第一个开始的n个元素；takeLast–返回从最后一个开始的n个元素；takeWhile–返回不满足条件的下标前面的所有元素的集合； 12345678filter &#123; !it.isEmpty() &#125;[-------split:][main]111[-------split:][main]222[-------split:][main]333[-------split:][main]aaa[-------split:][main]bbb[-------split:][main]ccc 参考链接点击 显式转换&amp;强制转换每个数字类型支持如下的转换: 1234567&gt; toByte(): Byte&gt; toShort(): Short&gt; toInt(): Int&gt; toLong(): Long&gt; toFloat(): Float&gt; toDouble(): Double&gt; toChar(): Char 强制转换xxx as 类：强制转换，可能崩溃 xxx as? 类：安全的强制转换，转换失败返回null 注意：数字类型的转换也可以使用as ，编译时不报错，但运行时会报错。 Lambda argument should be moved out of parentheses解决方式：option+enter； return@标签跳转到指定的位置，标签的写法很简单，只需要名字之后加@符号，要用的时候@名字就好，一般在lambda表达式中可能会用到。 1234567891011fun print(vararg msgs: String) &#123; Async.io &#123; for (msg in msgs) &#123; XLog.e(&quot;-------print:&quot;,msg) &#125; return@io XLog.e(&quot;-------print:&quot;,&quot;8&quot;) &#125; XLog.e(&quot;-------print:&quot;,&quot;9&quot;) &#125; 输出 12345[-------print:][main]9[-------print:][IOExecutor#1]a[-------print:][IOExecutor#1]b[-------print:][IOExecutor#1]c[-------print:][IOExecutor#1]d for循环使用方法在Kotlin中想遍历1-100的数值可以这样写： 123for (index in 1..10)&#123; print(index)//会输出1..10&#125; 这样写是正序遍历，如果想倒序遍历就该使用标准库中定义的downTo()函数： 123for (index in 10 downTo 1)&#123; print(index)//会输出10..1&#125; 想不使用1作为遍历的步长，可以使用step()函数： 123for (index in 1..100 step 2)&#123; print(index)//会输出1..3..5......&#125; 要创建一个不包含末尾元素的区间： 123for (index in 1 until 10)&#123; println(index)//输出1..9&#125; 遍历一个数组/列表，想同时取出下标和元素： 1234567val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)for ((index,e) in array.withIndex())&#123; println(&quot;下标=$index----元素=$e&quot;)&#125;[-----index:][main]下标=0----元素=a[-----index:][main]下标=1----元素=b[-----index:][main]下标=2----元素=c 遍历一个数组/列表，只取出下标: 1234val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)for (index in array.indices)&#123; println(&quot;index=$index&quot;)//输出0，1，2&#125; 遍历取元素： 1234val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)for (element in array)&#123; println(&quot;element=$element&quot;)//输出a,b,c&#125; .classService::class.java的语法展现了如何获取java.lang.Class对应的Kotlin类，这和Java中的Service.Class是完全等同的. java通配符&amp;kotlin声明处型变java 123456789101112131415161718192021222324public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; // 校验略 ListIterator&lt;? super T&gt; di = dest.listIterator(); ListIterator&lt;? extends T&gt; si = src.listIterator(); while (si.hasNext()) &#123; /** * 编译时异常 * Incompatible types.不兼容类型； * Required:T; * Found:Capture&lt;? super T&gt; */ T elementD =di.next(); T element = si.next(); //src extent 生产者 作为方法返回值类型是安全的 di.set(element); // dest super 消费者 作为方法参数类型是安全的 /** * 编译时异常 * set(&lt;? extends T&gt;) in ListIterator cannot be applied. * to (T) */ si.set(elementD); &#125; &#125; kotlin: 1234567891011121314151617abstract class Supplier&lt;out T&gt; &#123; abstract fun get(): T /** * 编译期错误： * Type parameter T is declared as &apos;out&apos; but occurs in &apos;in&apos; position in type T */ abstract fun set(t: T) &#125; abstract class Customer&lt;in T&gt; &#123; abstract fun set(t: T) /** * 编译期错误： * Type parameter T is declared as &apos;in&apos; but occurs in &apos;out&apos; position in type T */ abstract fun get(): T &#125; 1.List&lt;? extends T&gt;协变：== out 在si.set(elementD)中， elementD的类型是T，所以我们可以set（T t），以及一切参数中含有 T 的方法（称为消费者方法），T类型或者从T继承的类型都可以被set，但是因为可以set不同的类型，所以这些方法可能会破坏类型安全，所以编译器限制这些方法的调用。 举kotlin例说明： 有一方法 123fun generate(args : Array&lt;Any&gt;)&#123;//todo&#125; 我们调用它： 12val args : Array&lt;String&gt; = arrayOf()generate(args) 这个时候会提示异常（类型不匹配）：type mismitch，为了解决这个问题，我们只需要修改一下调用方法，使用型变out即可。 123fun generate(args : Array&lt;out Any&gt;)&#123; //todo&#125; List&lt;? super T&gt;逆变：== in 同协变正好相反，在T elementD =di.next();中，因为di的类型是&lt;? super T&gt;，所以我们通过di.next()获取的类型可能T,也可能是从T继承的类型，从而我们不能确定next的类型。注意，这次拒绝的理由跟协变中是不一样的。get方法并不会破坏泛型类的类型安全，主要原因在于我们不能确定get的返回类型。 参考链接1 参考链接2 ?: ?. !!操作符?. == If not null?.就是当前面的变量!= nuil 时正常调用，如果为null就为null;并且?.可以连续使用。例如user?.userName?.length !!! == npe!!,加在变量名后，就是当变量为null时，抛出空指针异常; ?: == if null?: 仅仅在左边的表达式结果为null时才会计算 ?: 后面的表达式 1234567val map = XXXXX ?: return等同于val map = XXXXXif(map == null)&#123; return&#125;但是if会有://Replace &apos;if&apos; with elvis operator toString()12345/** * Returns a string representation of the object. Can be called with a null receiver, in which case * it returns the string &quot;null&quot;. */public fun Any?.toString(): String 疑问点：null.toString()反编译String.valueOf(null) Serializable1class XXXXKT:Serializable&#123;&#125; Cannot access ‘Serializable’:it is internal in ‘kotlin.io’ 解决：import java.io.Serializable @Suppress(“UNCHECKED_CAST”)当使用 as Array强转时可能会出现Unchecked cast: Any! to Array 警告。解决方法就是在强转代码前加@Suppress(“UNCHECKED_CAST”)。备注：@SuppressWarnings(“unchecked”)使用时机呢？ 参考资料Runoob kotlincn Kotlin学习笔记","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://nunu03.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://nunu03.github.io/tags/Kotlin/"}]},{"title":"Hexo 配置","slug":"hello-world","date":"2019-07-02T03:36:38.000Z","updated":"2019-07-02T06:01:39.000Z","comments":true,"path":"2019/07/02/hello-world/","link":"","permalink":"http://nunu03.github.io/2019/07/02/hello-world/","excerpt":"通过git+hexo搭建个人博客","text":"通过git+hexo搭建个人博客 More info: Deployment 1234567891011npm install -g hexohexo inithexo ghexo shexo dnpm install hexo-deployer-git --savehexo dnpm install hexo --savehexo new &apos;kotlin使用笔记&apos;出现异常：使用下面命令，安装所有插件。npm ls --depth 0","categories":[],"tags":[]}]}